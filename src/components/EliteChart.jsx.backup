import React, { useEffect, useRef, useState } from 'react';
import { createChart } from 'lightweight-charts';
import {
    PlayCircle,
    PauseCircle,
    RotateCcw,
    Settings,
    TrendingUp,
    TrendingDown,
    Activity,
    BarChart3,
    Layers,
    ChevronLeft,
    ChevronRight,
    Eye,
    EyeOff,
    Camera,
    ChevronDown,
    MessageSquare
} from 'lucide-react';
import {
    calculateEMA,
    calculateRSI,
    calculateMACD,
    calculateBollingerBands,
    calculateSupportResistance,
    calculateATR,
    getCurrentValue
} from '../utils/technicalIndicators';
import PatternChatPanel from './PatternChatPanel';

const EliteChart = () => {
    // Chart refs
    const chartContainerRef = useRef(null);
    const chartRef = useRef(null);
    const mainSeriesRef = useRef(null);
    const volumeSeriesRef = useRef(null);
    const indicatorSeriesRefs = useRef({});
    const priceLineRefs = useRef([]);

    // Data state
    const [chartData, setChartData] = useState([]);
    const [symbol, setSymbol] = useState('BTCUSDT');
    const [interval, setInterval] = useState('1m');
    const [isStreaming, setIsStreaming] = useState(false);
    const [currentPrice, setCurrentPrice] = useState(0);
    const [priceChange, setPriceChange] = useState(0);

    // UI state
    const [chartType, setChartType] = useState('candlestick');
    const [theme, setTheme] = useState('light');
    const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false);
    const [showIndicatorsDropdown, setShowIndicatorsDropdown] = useState(false);
    const [showAIChat, setShowAIChat] = useState(false);

    // Indicators state
    const [selectedIndicators, setSelectedIndicators] = useState({
        ema9: false,
        ema21: false,
        ema50: false,
        ema100: false,
        ema200: false,
        rsi: false,
        macd: false,
        bollingerBands: false,
        supportResistance: true,
        atr: false
    });
    const [calculatedIndicators, setCalculatedIndicators] = useState({});

    // Simulation state
    const [simulationMode, setSimulationMode] = useState(null);
    const [simulationActive, setSimulationActive] = useState(false);
    const [isPlaying, setIsPlaying] = useState(false);
    const [playbackSpeed, setPlaybackSpeed] = useState(1);
    const [simulationStep, setSimulationStep] = useState(0);
    const [scenarioData, setScenarioData] = useState(null);
    const [projectionSeries, setProjectionSeries] = useState(null);

    // WebSocket ref
    const wsRef = useRef(null);

    // Token options
    const tokenOptions = [
        { symbol: 'BTCUSDT', name: 'Bitcoin' },
        { symbol: 'ETHUSDT', name: 'Ethereum' },
        { symbol: 'SOLUSDT', name: 'Solana' },
        { symbol: 'BNBUSDT', name: 'BNB' },
        { symbol: 'XRPUSDT', name: 'XRP' },
        { symbol: 'ADAUSDT', name: 'Cardano' },
        { symbol: 'DOGEUSDT', name: 'Dogecoin' },
        { symbol: 'DOTUSDT', name: 'Polkadot' },
        { symbol: 'AVAXUSDT', name: 'Avalanche' },
        { symbol: 'LINKUSDT', name: 'Chainlink' }
    ];

    // Initialize chart
    useEffect(() => {
        if (!chartContainerRef.current) return;

        const chart = createChart(chartContainerRef.current, {
            width: chartContainerRef.current.clientWidth,
            height: chartContainerRef.current.clientHeight,
            layout: {
                background: { color: theme === 'dark' ? '#0f172a' : '#ffffff' },
                textColor: theme === 'dark' ? '#cbd5e1' : '#334155',
                fontSize: 12,
                fontFamily: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
            },
            grid: {
                vertLines: { color: theme === 'dark' ? '#1e293b' : '#f1f5f9' },
                horzLines: { color: theme === 'dark' ? '#1e293b' : '#f1f5f9' }
            },
            crosshair: {
                mode: 1,
                vertLine: {
                    color: '#8b5cf6',
                    width: 1,
                    style: 3,
                    labelBackgroundColor: '#8b5cf6'
                },
                horzLine: {
                    color: '#8b5cf6',
                    width: 1,
                    style: 3,
                    labelBackgroundColor: '#8b5cf6'
                }
            },
            rightPriceScale: {
                borderColor: theme === 'dark' ? '#334155' : '#cbd5e1',
                scaleMargins: {
                    top: 0.1,
                    bottom: 0.25
                }
            },
            timeScale: {
                borderColor: theme === 'dark' ? '#334155' : '#cbd5e1',
                timeVisible: true,
                secondsVisible: false
            },
            handleScroll: {
                mouseWheel: true,
                pressedMouseMove: true,
                horzTouchDrag: true,
                vertTouchDrag: true
            },
            handleScale: {
                axisPressedMouseMove: true,
                mouseWheel: true,
                pinch: true
            }
        });

        chartRef.current = chart;

        // Add volume series first (background)
        const volumeSeries = chart.addHistogramSeries({
            color: '#8b5cf6',
            priceFormat: {
                type: 'volume'
            },
            priceScaleId: '',
            scaleMargins: {
                top: 0.85,
                bottom: 0
            }
        });
        volumeSeriesRef.current = volumeSeries;

        // Add main series (candlestick by default)
        const candlestickSeries = chart.addCandlestickSeries({
            upColor: '#22c55e',
            downColor: '#ef4444',
            borderUpColor: '#22c55e',
            borderDownColor: '#ef4444',
            wickUpColor: '#22c55e',
            wickDownColor: '#ef4444'
        });
        mainSeriesRef.current = candlestickSeries;

        // Handle resize
        const handleResize = () => {
            if (chartContainerRef.current && chartRef.current) {
                chartRef.current.applyOptions({
                    width: chartContainerRef.current.clientWidth,
                    height: chartContainerRef.current.clientHeight
                });
            }
        };

        window.addEventListener('resize', handleResize);

        return () => {
            window.removeEventListener('resize', handleResize);
            chart.remove();
        };
    }, [theme]);

    // Update chart type
    const updateChartType = (type) => {
        if (!chartRef.current) return;

        // Remove old series
        if (mainSeriesRef.current) {
            chartRef.current.removeSeries(mainSeriesRef.current);
        }

        let newSeries;
        if (type === 'candlestick') {
            newSeries = chartRef.current.addCandlestickSeries({
                upColor: '#22c55e',
                downColor: '#ef4444',
                borderUpColor: '#22c55e',
                borderDownColor: '#ef4444',
                wickUpColor: '#22c55e',
                wickDownColor: '#ef4444'
            });
        } else if (type === 'line') {
            newSeries = chartRef.current.addLineSeries({
                color: '#8b5cf6',
                lineWidth: 2
            });
        } else if (type === 'area') {
            newSeries = chartRef.current.addAreaSeries({
                topColor: 'rgba(139, 92, 246, 0.4)',
                bottomColor: 'rgba(139, 92, 246, 0.0)',
                lineColor: '#8b5cf6',
                lineWidth: 2
            });
        }

        mainSeriesRef.current = newSeries;

        // Reapply data if available
        if (chartData && chartData.length > 0) {
            if (type === 'candlestick') {
                newSeries.setData(chartData);
            } else {
                const lineData = chartData.map(d => ({
                    time: d.time,
                    value: d.close
                }));
                newSeries.setData(lineData);
            }
        }
    };

    // Handle chart type change
    useEffect(() => {
        if (chartRef.current && mainSeriesRef.current) {
            updateChartType(chartType);
        }
    }, [chartType]);

    // Fetch initial data
    const fetchInitialData = async () => {
        try {
            const response = await fetch(
                `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=500`
            );
            const data = await response.json();

            const formattedData = data.map(k => ({
                time: parseInt(k[0]) / 1000,
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            }));

            setChartData(formattedData);

            // Update chart
            if (mainSeriesRef.current) {
                if (chartType === 'candlestick') {
                    mainSeriesRef.current.setData(formattedData);
                } else {
                    const lineData = formattedData.map(d => ({
                        time: d.time,
                        value: d.close
                    }));
                    mainSeriesRef.current.setData(lineData);
                }
            }
            if (volumeSeriesRef.current) {
                const volumeData = formattedData.map(d => ({
                    time: d.time,
                    value: d.volume,
                    color: d.close >= d.open ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)'
                }));
                volumeSeriesRef.current.setData(volumeData);
            }

            // Calculate price change
            if (formattedData.length >= 2) {
                const firstPrice = formattedData[0].open;
                const lastPrice = formattedData[formattedData.length - 1].close;
                const change = ((lastPrice - firstPrice) / firstPrice) * 100;
                setPriceChange(change);
                setCurrentPrice(lastPrice);
            }
        } catch (error) {
            console.error('Error fetching initial data:', error);
        }
    };

    // Connect WebSocket
    const connectWebSocket = () => {
        if (wsRef.current?.readyState === WebSocket.OPEN) return;

        try {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            let apiBaseUrl = import.meta.env.VITE_API_URL || 'http://localhost:8000';
            if (apiBaseUrl === 'your_key_here' || !apiBaseUrl.startsWith('http')) {
                apiBaseUrl = 'http://localhost:8000';
            }
            const wsHost = apiBaseUrl.replace('http://', '').replace('https://', '');
            const wsUrl = `${wsProtocol}//${wsHost}/ws/prices`;

            const ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('✅ WebSocket connected');
                setIsStreaming(true);
                ws.send(JSON.stringify({
                    type: 'subscribe_kline',
                    symbol: symbol.toLowerCase(),
                    interval: interval
                }));
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message.type === 'kline_update' && message.symbol.toUpperCase() === symbol) {
                        const kline = message.kline;
                        const newCandle = {
                            time: parseInt(kline.T) / 1000,
                            open: parseFloat(kline.o),
                            high: parseFloat(kline.h),
                            low: parseFloat(kline.l),
                            close: parseFloat(kline.c),
                            volume: parseFloat(kline.v)
                        };

                        // Update chart
                        if (mainSeriesRef.current) {
                            if (chartType === 'candlestick') {
                                mainSeriesRef.current.update(newCandle);
                            } else {
                                mainSeriesRef.current.update({
                                    time: newCandle.time,
                                    value: newCandle.close
                                });
                            }
                        }
                        if (volumeSeriesRef.current) {
                            volumeSeriesRef.current.update({
                                time: newCandle.time,
                                value: newCandle.volume,
                                color: newCandle.close >= newCandle.open ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)'
                            });
                        }

                        setCurrentPrice(newCandle.close);
                        setChartData(prev => {
                            const newData = [...prev];
                            const lastCandle = newData[newData.length - 1];
                            if (lastCandle && lastCandle.time === newCandle.time) {
                                newData[newData.length - 1] = newCandle;
                            } else {
                                newData.push(newCandle);
                                if (newData.length > 500) newData.shift();
                            }
                            return newData;
                        });
                    }
                } catch (error) {
                    console.error('WebSocket message error:', error);
                }
            };

            ws.onerror = (error) => console.error('WebSocket error:', error);
            ws.onclose = () => {
                console.log('WebSocket disconnected');
                setIsStreaming(false);
            };

            wsRef.current = ws;
        } catch (error) {
            console.error('Failed to connect WebSocket:', error);
        }
    };

    // Disconnect WebSocket
    const disconnectWebSocket = () => {
        if (wsRef.current) {
            wsRef.current.send(JSON.stringify({
                type: 'unsubscribe_kline',
                symbol: symbol.toLowerCase(),
                interval: interval
            }));
            wsRef.current.close();
            wsRef.current = null;
            setIsStreaming(false);
        }
    };

    // Handle symbol/interval change
    useEffect(() => {
        if (isStreaming) {
            disconnectWebSocket();
            setTimeout(() => {
                fetchInitialData().then(() => connectWebSocket());
            }, 500);
        }
    }, [symbol, interval]);

    // Start/stop streaming
    const toggleStreaming = async () => {
        if (isStreaming) {
            disconnectWebSocket();
        } else {
            await fetchInitialData();
            connectWebSocket();
        }
    };

    // Calculate indicators
    useEffect(() => {
        if (chartData.length < 2) return;

        const indicators = {};

        if (selectedIndicators.ema9) indicators.ema9 = calculateEMA(chartData, 9);
        if (selectedIndicators.ema21) indicators.ema21 = calculateEMA(chartData, 21);
        if (selectedIndicators.ema50) indicators.ema50 = calculateEMA(chartData, 50);
        if (selectedIndicators.ema100) indicators.ema100 = calculateEMA(chartData, 100);
        if (selectedIndicators.ema200) indicators.ema200 = calculateEMA(chartData, 200);
        if (selectedIndicators.rsi) indicators.rsi = calculateRSI(chartData, 14);
        if (selectedIndicators.macd) {
            const macdData = calculateMACD(chartData);
            indicators.macd = macdData.macd;
            indicators.macdSignal = macdData.signal;
            indicators.macdHistogram = macdData.histogram;
        }
        if (selectedIndicators.bollingerBands) {
            const bbData = calculateBollingerBands(chartData, 20, 2);
            indicators.bbUpper = bbData.upper;
            indicators.bbMiddle = bbData.middle;
            indicators.bbLower = bbData.lower;
        }
        if (selectedIndicators.supportResistance) {
            const srData = calculateSupportResistance(chartData, 20);
            indicators.support = srData.support.slice(0, 2);
            indicators.resistance = srData.resistance.slice(0, 2);
        }
        if (selectedIndicators.atr) indicators.atr = calculateATR(chartData, 14);

        setCalculatedIndicators(indicators);
    }, [chartData, selectedIndicators]);

    // Update indicator lines and price lines on chart
    useEffect(() => {
        if (!chartRef.current || chartData.length === 0) return;

        // Clear existing indicator series
        Object.values(indicatorSeriesRefs.current).forEach(series => {
            if (series) chartRef.current.removeSeries(series);
        });
        indicatorSeriesRefs.current = {};

        // Clear existing price lines
        priceLineRefs.current.forEach(line => {
            if (line && mainSeriesRef.current) {
                mainSeriesRef.current.removePriceLine(line);
            }
        });
        priceLineRefs.current = [];

        // Add EMA lines
        const emaColors = {
            ema9: '#f59e0b',
            ema21: '#3b82f6',
            ema50: '#8b5cf6',
            ema100: '#ec4899',
            ema200: '#ef4444'
        };

        Object.keys(emaColors).forEach(emaKey => {
            if (selectedIndicators[emaKey] && calculatedIndicators[emaKey]) {
                const series = chartRef.current.addLineSeries({
                    color: emaColors[emaKey],
                    lineWidth: 2,
                    title: emaKey.toUpperCase()
                });
                const data = calculatedIndicators[emaKey].map((value, i) => ({
                    time: chartData[i].time,
                    value: value
                })).filter(d => d.value !== null);
                series.setData(data);
                indicatorSeriesRefs.current[emaKey] = series;
            }
        });

        // Add Bollinger Bands
        if (selectedIndicators.bollingerBands && calculatedIndicators.bbUpper) {
            ['bbUpper', 'bbMiddle', 'bbLower'].forEach((bb, idx) => {
                const series = chartRef.current.addLineSeries({
                    color: idx === 1 ? '#6366f1' : '#a78bfa',
                    lineWidth: idx === 1 ? 2 : 1,
                    lineStyle: idx === 1 ? 0 : 2,
                    title: bb.toUpperCase()
                });
                const data = calculatedIndicators[bb].map((value, i) => ({
                    time: chartData[i].time,
                    value: value
                })).filter(d => d.value !== null);
                series.setData(data);
                indicatorSeriesRefs.current[bb] = series;
            });
        }

        // Add Support/Resistance lines
        if (selectedIndicators.supportResistance && mainSeriesRef.current) {
            if (calculatedIndicators.support) {
                calculatedIndicators.support.forEach((level, idx) => {
                    const line = mainSeriesRef.current.createPriceLine({
                        price: level.price,
                        color: '#22c55e',
                        lineWidth: 2,
                        lineStyle: 2,
                        axisLabelVisible: true,
                        title: `S${idx + 1}`
                    });
                    priceLineRefs.current.push(line);
                });
            }
            if (calculatedIndicators.resistance) {
                calculatedIndicators.resistance.forEach((level, idx) => {
                    const line = mainSeriesRef.current.createPriceLine({
                        price: level.price,
                        color: '#ef4444',
                        lineWidth: 2,
                        lineStyle: 2,
                        axisLabelVisible: true,
                        title: `R${idx + 1}`
                    });
                    priceLineRefs.current.push(line);
                });
            }
        }
    }, [calculatedIndicators, selectedIndicators, chartData]);

    // Generate scenario simulation
    const generateScenario = (type) => {
        if (!chartData || chartData.length < 10) {
            alert('Not enough data to generate scenario. Please start streaming first.');
            return;
        }

        const lastPrice = currentPrice;
        const avgVolatility = calculatedIndicators.atr ? getCurrentValue(calculatedIndicators.atr) : lastPrice * 0.02;

        let scenario = null;

        switch (type) {
            case 'long':
                const supportLevel = calculatedIndicators.support?.[0]?.price || lastPrice * 0.98;
                scenario = {
                    type: 'Long Support',
                    entryPrice: supportLevel,
                    targetPrice: supportLevel + (avgVolatility * 2),
                    stopLoss: supportLevel - (avgVolatility * 0.5),
                    description: 'Long opportunity at support level'
                };
                break;
            case 'short':
                const resistanceLevel = calculatedIndicators.resistance?.[0]?.price || lastPrice * 1.02;
                scenario = {
                    type: 'Short Resistance',
                    entryPrice: resistanceLevel,
                    targetPrice: resistanceLevel - (avgVolatility * 2),
                    stopLoss: resistanceLevel + (avgVolatility * 0.5),
                    description: 'Short opportunity at resistance level'
                };
                break;
            case 'breakout':
                const breakoutLevel = calculatedIndicators.resistance?.[0]?.price || lastPrice * 1.02;
                scenario = {
                    type: 'Breakout',
                    entryPrice: breakoutLevel,
                    targetPrice: breakoutLevel + (avgVolatility * 3),
                    stopLoss: breakoutLevel - (avgVolatility * 0.3),
                    description: 'Breakout above resistance'
                };
                break;
            case 'breakdown':
                const breakdownLevel = calculatedIndicators.support?.[0]?.price || lastPrice * 0.98;
                scenario = {
                    type: 'Breakdown',
                    entryPrice: breakdownLevel,
                    targetPrice: breakdownLevel - (avgVolatility * 3),
                    stopLoss: breakdownLevel + (avgVolatility * 0.3),
                    description: 'Breakdown below support'
                };
                break;
            case 'mean-reversion':
                const middleBB = calculatedIndicators.bbMiddle ? getCurrentValue(calculatedIndicators.bbMiddle) : lastPrice;
                scenario = {
                    type: 'Mean Reversion',
                    entryPrice: lastPrice,
                    targetPrice: middleBB,
                    stopLoss: lastPrice > middleBB ? lastPrice + avgVolatility : lastPrice - avgVolatility,
                    description: 'Mean reversion to middle BB'
                };
                break;
        }

        if (scenario) {
            const riskReward = Math.abs((scenario.targetPrice - scenario.entryPrice) / (scenario.entryPrice - scenario.stopLoss));
            scenario.riskReward = riskReward.toFixed(2);
            scenario.potentialGain = (((scenario.targetPrice - scenario.entryPrice) / scenario.entryPrice) * 100).toFixed(2);
            scenario.potentialLoss = (((scenario.entryPrice - scenario.stopLoss) / scenario.entryPrice) * 100).toFixed(2);

            // Draw scenario lines on chart
            if (mainSeriesRef.current) {
                const entryLine = mainSeriesRef.current.createPriceLine({
                    price: scenario.entryPrice,
                    color: '#3b82f6',
                    lineWidth: 2,
                    lineStyle: 0,
                    axisLabelVisible: true,
                    title: 'Entry'
                });
                const targetLine = mainSeriesRef.current.createPriceLine({
                    price: scenario.targetPrice,
                    color: '#22c55e',
                    lineWidth: 2,
                    lineStyle: 0,
                    axisLabelVisible: true,
                    title: 'Target'
                });
                const stopLine = mainSeriesRef.current.createPriceLine({
                    price: scenario.stopLoss,
                    color: '#ef4444',
                    lineWidth: 2,
                    lineStyle: 0,
                    axisLabelVisible: true,
                    title: 'Stop Loss'
                });
                priceLineRefs.current.push(entryLine, targetLine, stopLine);
            }

            setScenarioData(scenario);
            setSimulationActive(true);
            setSimulationMode(type);
        }
    };

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            disconnectWebSocket();
        };
    }, []);

    return (
        <div className="h-screen w-full bg-gradient-to-br from-slate-50 via-white to-purple-50 flex flex-col overflow-hidden">
            {/* Top Toolbar */}
            <div className="bg-white/80 backdrop-blur-xl border-b border-slate-200/50 shadow-sm">
                <div className="flex items-center justify-between px-6 py-3">
                    {/* Left: Symbol & Price */}
                    <div className="flex items-center gap-6">
                        <div className="flex items-center gap-3">
                            <select
                                value={symbol}
                                onChange={(e) => setSymbol(e.target.value)}
                                disabled={isStreaming}
                                className="px-4 py-2 bg-white/90 border border-slate-200 rounded-xl font-semibold text-slate-800 hover:border-purple-300 focus:outline-none focus:ring-2 focus:ring-purple-500/50 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                {tokenOptions.map(token => (
                                    <option key={token.symbol} value={token.symbol}>{token.name}</option>
                                ))}
                            </select>
                            <div className="flex flex-col">
                                <div className="text-2xl font-bold text-slate-900">
                                    ${currentPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                                </div>
                                <div className={`text-sm font-semibold ${priceChange >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                                    {priceChange >= 0 ? '+' : ''}{priceChange.toFixed(2)}%
                                </div>
                            </div>
                        </div>

                        {/* Timeframe selector */}
                        <div className="flex gap-1 bg-slate-100 rounded-lg p-1">
                            {['1m', '5m', '15m', '1h', '4h', '1d'].map(tf => (
                                <button
                                    key={tf}
                                    onClick={() => setInterval(tf)}
                                    disabled={isStreaming}
                                    className={`px-3 py-1.5 rounded-md text-sm font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed ${interval === tf
                                        ? 'bg-white text-purple-600 shadow-sm'
                                        : 'text-slate-600 hover:text-slate-900'
                                        }`}
                                >
                                    {tf}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Right: Controls */}
                    <div className="flex items-center gap-3">
                        {/* Chart type */}
                        <div className="flex gap-1 bg-slate-100 rounded-lg p-1">
                            {[
                                { type: 'candlestick', icon: BarChart3, label: 'Candles' },
                                { type: 'line', icon: Activity, label: 'Line' },
                                { type: 'area', icon: Layers, label: 'Area' }
                            ].map(({ type, icon: Icon, label }) => (
                                <button
                                    key={type}
                                    onClick={() => setChartType(type)}
                                    className={`px-3 py-1.5 rounded-md text-sm font-medium flex items-center gap-1.5 transition-all ${chartType === type
                                        ? 'bg-white text-purple-600 shadow-sm'
                                        : 'text-slate-600 hover:text-slate-900'
                                        }`}
                                    title={label}
                                >
                                    <Icon size={16} />
                                </button>
                            ))}
                        </div>

                        {/* AI Chat toggle */}
                        <button
                            onClick={() => setShowAIChat(!showAIChat)}
                            className={`px-4 py-2 rounded-xl font-semibold flex items-center gap-2 transition-all ${showAIChat
                                ? 'bg-purple-500 text-white'
                                : 'bg-slate-100 text-slate-700 hover:bg-slate-200'
                                }`}
                        >
                            <MessageSquare size={18} />
                            AI Chat
                        </button>

                        {/* Stream toggle */}
                        <button
                            onClick={toggleStreaming}
                            className={`px-4 py-2 rounded-xl font-semibold flex items-center gap-2 transition-all ${isStreaming
                                ? 'bg-red-500 hover:bg-red-600 text-white'
                                : 'bg-green-500 hover:bg-green-600 text-white'
                                }`}
                        >
                            {isStreaming ? (
                                <>
                                    <div className="w-2 h-2 bg-white rounded-full animate-pulse" />
                                    Live
                                </>
                            ) : (
                                <>
                                    <PlayCircle size={18} />
                                    Start
                                </>
                            )}
                        </button>
                    </div>
                </div>
            </div>

            {/* Main Content */}
            <div className="flex-1 flex overflow-hidden">
                {/* Sidebar */}
                <div
                    className={`bg-white/80 backdrop-blur-xl border-r border-slate-200/50 transition-all duration-300 ${isSidebarCollapsed ? 'w-16' : 'w-80'
                        } flex flex-col`}
                >
                    {/* Collapse toggle */}
                    <button
                        onClick={() => setIsSidebarCollapsed(!isSidebarCollapsed)}
                        className="p-3 hover:bg-slate-100/50 transition-colors flex items-center justify-center"
                    >
                        {isSidebarCollapsed ? <ChevronRight size={20} /> : <ChevronLeft size={20} />}
                    </button>

                    {!isSidebarCollapsed && (
                        <div className="flex-1 overflow-y-auto p-4 space-y-4">
                            {/* Indicators Dropdown */}
                            <div className="space-y-2">
                                <button
                                    onClick={() => setShowIndicatorsDropdown(!showIndicatorsDropdown)}
                                    className="w-full flex items-center justify-between px-4 py-3 bg-slate-100 hover:bg-slate-200 rounded-xl transition-colors"
                                >
                                    <span className="text-sm font-bold text-slate-700">INDICATORS</span>
                                    <ChevronDown
                                        size={18}
                                        className={`transition-transform ${showIndicatorsDropdown ? 'rotate-180' : ''}`}
                                    />
                                </button>

                                {showIndicatorsDropdown && (
                                    <div className="space-y-1 pl-2">
                                        {[
                                            { key: 'ema9', label: 'EMA 9', color: 'bg-amber-500' },
                                            { key: 'ema21', label: 'EMA 21', color: 'bg-blue-500' },
                                            { key: 'ema50', label: 'EMA 50', color: 'bg-purple-500' },
                                            { key: 'ema100', label: 'EMA 100', color: 'bg-pink-500' },
                                            { key: 'ema200', label: 'EMA 200', color: 'bg-red-500' },
                                            { key: 'rsi', label: 'RSI (14)', color: 'bg-indigo-500' },
                                            { key: 'macd', label: 'MACD', color: 'bg-cyan-500' },
                                            { key: 'bollingerBands', label: 'Bollinger Bands', color: 'bg-violet-500' },
                                            { key: 'supportResistance', label: 'Support/Resistance', color: 'bg-emerald-500' },
                                            { key: 'atr', label: 'ATR (14)', color: 'bg-teal-500' }
                                        ].map(({ key, label, color }) => (
                                            <button
                                                key={key}
                                                onClick={() => setSelectedIndicators(prev => ({ ...prev, [key]: !prev[key] }))}
                                                className={`w-full px-3 py-2 rounded-lg flex items-center gap-2 transition-all ${selectedIndicators[key]
                                                    ? 'bg-purple-50 border-2 border-purple-300'
                                                    : 'bg-slate-50 border-2 border-transparent hover:border-slate-200'
                                                    }`}
                                            >
                                                <div className={`w-3 h-3 rounded-full ${color}`} />
                                                <span className="text-sm font-medium text-slate-700">{label}</span>
                                                {selectedIndicators[key] ? (
                                                    <Eye size={14} className="ml-auto text-purple-600" />
                                                ) : (
                                                    <EyeOff size={14} className="ml-auto text-slate-400" />
                                                )}
                                            </button>
                                        ))}
                                    </div>
                                )}
                            </div>

                            {/* Scenario Simulator */}
                            <div className="space-y-2">
                                <h3 className="text-sm font-bold text-slate-700 uppercase tracking-wide">Scenario Simulator</h3>
                                <div className="space-y-1">
                                    {[
                                        { type: 'long', label: 'Long Support', icon: TrendingUp, color: 'bg-green-500' },
                                        { type: 'short', label: 'Short Resistance', icon: TrendingDown, color: 'bg-red-500' },
                                        { type: 'breakout', label: 'Breakout', icon: TrendingUp, color: 'bg-blue-500' },
                                        { type: 'breakdown', label: 'Breakdown', icon: TrendingDown, color: 'bg-orange-500' },
                                        { type: 'mean-reversion', label: 'Mean Reversion', icon: Activity, color: 'bg-purple-500' }
                                    ].map(({ type, label, icon: Icon, color }) => (
                                        <button
                                            key={type}
                                            onClick={() => generateScenario(type)}
                                            className={`w-full px-3 py-2 rounded-lg flex items-center gap-2 transition-all ${simulationMode === type
                                                ? 'bg-purple-50 border-2 border-purple-300'
                                                : 'bg-slate-50 border-2 border-transparent hover:border-slate-200'
                                                }`}
                                        >
                                            <div className={`p-1 rounded ${color}`}>
                                                <Icon size={14} className="text-white" />
                                            </div>
                                            <span className="text-sm font-medium text-slate-700">{label}</span>
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {/* Active Scenario Info */}
                            {simulationActive && scenarioData && (
                                <div className="bg-gradient-to-br from-purple-50 to-blue-50 rounded-xl p-4 border border-purple-200">
                                    <div className="flex items-center justify-between mb-3">
                                        <h4 className="text-sm font-bold text-purple-900">{scenarioData.type}</h4>
                                        <button
                                            onClick={() => {
                                                setSimulationActive(false);
                                                setScenarioData(null);
                                                setSimulationMode(null);
                                                // Clear price lines
                                                priceLineRefs.current.forEach(line => {
                                                    if (line && mainSeriesRef.current) {
                                                        mainSeriesRef.current.removePriceLine(line);
                                                    }
                                                });
                                                priceLineRefs.current = [];
                                            }}
                                            className="text-slate-500 hover:text-slate-700"
                                        >
                                            ✕
                                        </button>
                                    </div>
                                    <div className="space-y-2 text-xs">
                                        <div className="flex justify-between">
                                            <span className="text-slate-600">Entry:</span>
                                            <span className="font-bold text-slate-900">${scenarioData.entryPrice.toFixed(2)}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span className="text-slate-600">Target:</span>
                                            <span className="font-bold text-green-600">${scenarioData.targetPrice.toFixed(2)}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span className="text-slate-600">Stop Loss:</span>
                                            <span className="font-bold text-red-600">${scenarioData.stopLoss.toFixed(2)}</span>
                                        </div>
                                        <div className="flex justify-between pt-2 border-t border-purple-200">
                                            <span className="text-slate-600">R:R Ratio:</span>
                                            <span className="font-bold text-purple-600">{scenarioData.riskReward}:1</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span className="text-slate-600">Potential Gain:</span>
                                            <span className="font-bold text-green-600">+{scenarioData.potentialGain}%</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span className="text-slate-600">Potential Loss:</span>
                                            <span className="font-bold text-red-600">-{scenarioData.potentialLoss}%</span>
                                        </div>
                                    </div>
                                    <div className="mt-3 pt-3 border-t border-purple-200">
                                        <p className="text-xs text-slate-600">{scenarioData.description}</p>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                </div>

                {/* Chart Area */}
                <div className="flex-1 relative">
                    {/* OHLC HUD */}
                    <div className="absolute top-4 left-4 z-10 bg-white/90 backdrop-blur-xl rounded-xl shadow-lg border border-slate-200/50 p-4">
                        <div className="flex gap-6 text-sm">
                            <div>
                                <div className="text-xs text-slate-500 mb-1">Open</div>
                                <div className="font-bold text-slate-900">
                                    ${chartData[chartData.length - 1]?.open.toFixed(2) || '—'}
                                </div>
                            </div>
                            <div>
                                <div className="text-xs text-slate-500 mb-1">High</div>
                                <div className="font-bold text-green-600">
                                    ${chartData[chartData.length - 1]?.high.toFixed(2) || '—'}
                                </div>
                            </div>
                            <div>
                                <div className="text-xs text-slate-500 mb-1">Low</div>
                                <div className="font-bold text-red-600">
                                    ${chartData[chartData.length - 1]?.low.toFixed(2) || '—'}
                                </div>
                            </div>
                            <div>
                                <div className="text-xs text-slate-500 mb-1">Close</div>
                                <div className="font-bold text-slate-900">
                                    ${chartData[chartData.length - 1]?.close.toFixed(2) || '—'}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Chart container */}
                    <div ref={chartContainerRef} className="w-full h-full" />

                    {/* Snapshot button */}
                    <button
                        className="absolute bottom-4 right-4 p-3 bg-white/90 backdrop-blur-xl rounded-xl shadow-lg border border-slate-200/50 hover:bg-purple-50 hover:border-purple-300 transition-all group"
                        title="Take snapshot (Alt+S)"
                    >
                        <Camera size={20} className="text-slate-600 group-hover:text-purple-600" />
                    </button>
                </div>

                {/* AI Chat Panel */}
                {showAIChat && (
                    <div className="w-96 border-l border-slate-200/50">
                        <PatternChatPanel />
                    </div>
                )}
            </div>
        </div>
    );
};

export default EliteChart;
